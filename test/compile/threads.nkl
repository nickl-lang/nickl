import std;

pthread_t :: u64;
pthread_attr_t :: u64;

// TODO Add #extern("c") to ThreadFunc type
ThreadFunc :: (arg: *void) -> *void;

LIBPTHREAD :: "libpthread.so.0";

#link(LIBPTHREAD) pthread_create :: (
    thread: *pthread_t,
    attr: *const pthread_attr_t,
    start_routine: ThreadFunc,
    arg: *void) -> i32;
#link(LIBPTHREAD) pthread_join :: (thread: pthread_t, retval: **void) -> i32;
#link(LIBPTHREAD) pthread_self :: () -> pthread_t;

#extern("c") thread :: (arg: *void) -> *void {
    std.printf("thread: arg='%s'\n", arg);
    std.printf("thread: id=%li\n", pthread_self());
    return "hello";
}

exec :: (name: *u8) -> void {
    thread_id: pthread_t;
    ret: *u8;

    if pthread_create(&thread_id, 0, thread, name) != 0 {
        std.printf("error: pthread_create() error");
        return;
    }

    if pthread_join(thread_id, &ret) != 0 {
        std.printf("error: pthread_join() error");
        return;
    }

    std.printf("exec: ret='%s'\n", ret);
}

main :: () -> i32 {
    ${ exec("Compile time threads!"); }
    exec("Run time threads!");

    return 0;
}

import compiler;
builder := compiler.createBuilder();
compiler.link(builder, LIBPTHREAD);
compiler.build(builder, main, "threads");
compiler.freeBuilder(builder);
