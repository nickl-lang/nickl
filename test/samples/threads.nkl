import std;

// impl

pthread_t :: u64;
pthread_attr_t :: u64;

ThreadFunc :: (arg: *void) -> *void;

#foreign("libpthread.so") pthread_create :: (
    thread: *pthread_t,
    attr: *const pthread_attr_t,
    start_routine: ThreadFunc,
    arg: *void) -> i32;
#foreign("libpthread.so") pthread_join ::(
    thread: pthread_t,
    retval: **void) -> i32;

// usage

ITER :: 10;

#extern("c") thread :: (arg: *void) -> *void {
    std.printf("thread() entered with argument '%s'\n", arg);
    i := 0;
    while i < ITER {
        std.printf("thread(): i=%li\n", i);
        i = i + 1;
    }
    return "hello";
}

main :: () -> i32 {
    thid: pthread_t;
    ret: *u8;

    if pthread_create(&thid, 0, thread, "thread 1") != 0 {
        std.printf("error: pthread_create() error");
        return 1;
    }

    std.nanosleep(&std.timespec{0, 10000}, 0);

    i := 0;
    while i < ITER {
        std.printf("main(): i=%li\n", i);
        i = i + 1;
    }

    if pthread_join(thid, &ret) != 0 {
        std.printf("error: pthread_create() error");
        return 3;
    }

    std.printf("thread exited with '%s'\n", ret);
}

main();

import compiler;
builder := compiler.createBuilder();
compiler.link(builder, "libpthread.so");
compiler.build(builder, main, "threads_test");
compiler.freeBuilder(builder);
