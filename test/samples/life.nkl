import std;

FPS :: 30;

ROWS :: 30;
COLS :: 60;

NS_IN_S :: 1000000000;
FRAMETIME_NS :: NS_IN_S / FPS;

s_field: [2][ROWS * COLS]u8;

s_cur_buf := 0;

s_cursor_x := 0;
s_cursor_y := 0;

s_quit := false;

pmod :: (x: i64, n: i64) -> i64 {
    return (x % n + n) % n;
}

nextBuf :: () -> i64 {
    return (s_cur_buf + 1) % 2;
}

swapBufs :: () -> void {
    s_cur_buf = nextBuf();
}

atBuf :: (x: i64, y: i64, buf: i64) -> *u8 {
    return &s_field[buf][(pmod(y, COLS) * ROWS + pmod(x, ROWS))];
}

at :: (x: i64, y: i64) -> *u8 {
    return atBuf(x, y, s_cur_buf);
}

nextAt :: (x: i64, y: i64) -> *u8 {
    return atBuf(x, y, nextBuf());
}

get :: (x: i64, y: i64) -> u8 {
    return at(x, y).*;
}

set :: (x: i64, y: i64, v: u8) -> void {
    at(x, y).* = v;
}

setNext :: (x: i64, y: i64, v: u8) -> void {
    nextAt(x, y).* = v;
}

getTimestamp :: () -> i64 {
    ts: std.timespec;
    std.clock_gettime(std.CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * NS_IN_S + ts.tv_nsec;
}

step :: () -> void {
    x := 0; while x < ROWS {
        y := 0; while y < COLS {
            sum := 0;
            dx := -1; while dx <= 1 {
                dy := -1; while dy <= 1 {
                    sum = sum + get(x + dx, y + dy);
                    dy = dy + 1;
                }
                dx = dx + 1;
            }
            if get(x, y) setNext(x, y, sum-1 >= 2 && sum-1 <= 3);
            else setNext(x, y, sum == 3);
            y = y + 1;
        }
        x = x + 1;
    }
    swapBufs();
}

// TODO Cannot do char literals
ESC :: i32{27};

main :: () -> i32 {
    std.system("stty -icanon -echo");

    fl := std.fcntl(std.STDIN_FILENO, std.F_GETFL, 0);
    std.fcntl(std.STDIN_FILENO, std.F_SETFL, fl | std.O_NONBLOCK);

    std.putchar(ESC); std.printf("[?25l");

    empty_row: [COLS]u8;
    std.memset(cast(*void) &empty_row, cast(i32) "."[0], cast(u64) COLS);

    running := false;

    prev_ts := getTimestamp();

    while s_quit != true {
        c: u8;

        c = cast(u8) std.getchar();

        if      c ==  "q"[0] s_quit = true;
        else if c ==  "w"[0] s_cursor_x = pmod(s_cursor_x - 1, ROWS);
        else if c ==  "a"[0] s_cursor_y = pmod(s_cursor_y - 1, COLS);
        else if c ==  "s"[0] s_cursor_x = pmod(s_cursor_x + 1, ROWS);
        else if c ==  "d"[0] s_cursor_y = pmod(s_cursor_y + 1, COLS);
        else if c ==  " "[0] set(s_cursor_x, s_cursor_y, u8{1} - get(s_cursor_x, s_cursor_y));
        else if c == "\n"[0] running = running ^ 1;
        else if c ==  "c"[0] std.memset(cast(*void) at(0, 0), i32{0}, cast(u64) (ROWS * COLS));
        else if c ==  "e"[0] step();

        if running {
            step();
        }

        x := 0; while x < ROWS {
            y := 0; while y < COLS {
                if running == false && x == s_cursor_x && y == s_cursor_y {
                    std.putchar(ESC); std.printf("[30m");
                    std.putchar(ESC); std.printf("[47m");
                }
                if get(x, y) std.printf("#"); else std.printf(".");
                if running == false && x == s_cursor_x && y == s_cursor_y {
                    std.putchar(ESC); std.printf("[49m");
                    std.putchar(ESC); std.printf("[39m");
                }
                y = y + 1;
            }
            std.putchar(cast(i32) "\n"[0]);
            x = x + 1;
        }

        std.putchar(ESC); std.printf("[0G", ROWS);
        std.putchar(ESC); std.printf("[%iA", ROWS);

        ts := getTimestamp();
        elapsed_ns := ts - prev_ts;

        if elapsed_ns < FRAMETIME_NS {
            std.nanosleep(&std.timespec{0, FRAMETIME_NS - elapsed_ns}, cast(*std.timespec) u64{0});
        }

        prev_ts = ts;
    }

    std.putchar(ESC); std.printf("[?25h");

    std.fcntl(std.STDIN_FILENO, std.F_SETFL, fl);

    std.system("stty icanon echo");

    return i32{0};
}

import compiler;
builder := compiler.createBuilder();
compiler.build(builder, cast(compiler.EntryPoint) main, "life");
compiler.freeBuilder(builder);
